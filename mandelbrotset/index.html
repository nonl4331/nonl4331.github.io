<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
      
    

      <title> - Graphing the Mandelbrot Set</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js" integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy" crossorigin="anonymous"></script>
              
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
                  onload="renderMathInElement(document.body);"></script>
              
          
      

      
          <link rel="stylesheet" href="nonl.knao.net/site.css">
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="nonl.knao.net" class="logo">nonl</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="nonl.knao.net">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="nonl.knao.net&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="nonl.knao.net&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="nonl.knao.net&#x2F;about">
                            About
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="nonl.knao.net">nonl</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="nonl.knao.net">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="nonl.knao.net&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="nonl.knao.net&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                            <li>
                                <a href="nonl.knao.net&#x2F;about">
                                    About
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="nonl.knao.net/mandelbrotset/#multithreading" class="toc-link">Multithreading</a>
                    
                </li>
                
                <li>
                    <a href="nonl.knao.net/mandelbrotset/#optimising" class="toc-link">Optimising</a>
                    
                    <ul>
                        
                        <li>
                            <a href="nonl.knao.net/mandelbrotset/#early-exit" class="toc-link">Early Exit</a>
                        </li>
                        
                        <li>
                            <a href="nonl.knao.net/mandelbrotset/#symmetry" class="toc-link">Symmetry</a>
                        </li>
                        
                        <li>
                            <a href="nonl.knao.net/mandelbrotset/#cycles" class="toc-link">Cycles</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="nonl.knao.net/mandelbrotset/#better-graphing" class="toc-link">Better graphing</a>
                    
                </li>
                
                <li>
                    <a href="nonl.knao.net/mandelbrotset/#conclusion" class="toc-link">Conclusion</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="nonl.knao.net&#x2F;mandelbrotset&#x2F;">Graphing the Mandelbrot Set</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2023-06-10</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>The Mandelbrot set is defined as the set of complex numbers where if you take the function \(f_c(z) = z^2 + c\) and recursively evaulate it starting with \(z = 0\) and a given \(c\) where it does not diverge.
We can graph this by representing each pixel with position or \(c\) value on the complex plane.</p>
<span id="continue-reading"></span>
<p>I will be using Rust with minifb for a framebuffer and rayon for multithreading.</p>
<pre data-lang="toml" style="background-color:#2e3440;color:#d8dee9;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[dependencies]
</span><span style="color:#81a1c1;">minifb </span><span>= </span><span style="color:#a3be8c;">&quot;0.24.0&quot;
</span><span style="color:#81a1c1;">rayon </span><span>= </span><span style="color:#a3be8c;">&quot;1.7.0&quot;
</span></code></pre>
<p>First of all let's create a buffer for our image and set up minifb.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">use </span><span>minifb</span><span style="color:#81a1c1;">::</span><span>{Key</span><span style="color:#eceff4;">,</span><span> Window</span><span style="color:#eceff4;">,</span><span> WindowOptions}</span><span style="color:#eceff4;">;
</span><span style="color:#81a1c1;">use </span><span>std</span><span style="color:#81a1c1;">::</span><span>error</span><span style="color:#81a1c1;">::</span><span>Error</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">const </span><span>WIDTH</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span style="color:#b48ead;">2560</span><span style="color:#eceff4;">;
</span><span style="color:#81a1c1;">const </span><span>HEIGHT</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span style="color:#b48ead;">1440</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">main</span><span>() </span><span style="color:#eceff4;">-&gt; </span><span style="color:#8fbcbb;">Result</span><span>&lt;(), </span><span style="color:#8fbcbb;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    </span><span style="color:#81a1c1;">let mut</span><span> buffer</span><span style="color:#eceff4;">: </span><span style="color:#8fbcbb;">Vec</span><span>&lt;</span><span style="color:#81a1c1;">u32</span><span>&gt; </span><span style="color:#81a1c1;">= </span><span>vec![</span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">; </span><span>WIDTH </span><span style="color:#81a1c1;">* </span><span>HEIGHT]</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">let mut</span><span> window </span><span style="color:#81a1c1;">= </span><span>Window</span><span style="color:#81a1c1;">::</span><span>new(</span><span style="color:#a3be8c;">&quot;Mandelbrot Set&quot;</span><span style="color:#eceff4;">, </span><span>WIDTH</span><span style="color:#eceff4;">, </span><span>HEIGHT</span><span style="color:#eceff4;">, </span><span>WindowOptions</span><span style="color:#81a1c1;">::</span><span>default())</span><span style="color:#81a1c1;">?</span><span style="color:#eceff4;">;
</span><span>
</span><span>    window</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">limit_update_rate</span><span>(</span><span style="color:#8fbcbb;">Some</span><span>(std</span><span style="color:#81a1c1;">::</span><span>time</span><span style="color:#81a1c1;">::</span><span>Duration</span><span style="color:#81a1c1;">::</span><span>from_micros(</span><span style="color:#b48ead;">16600</span><span>)))</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">while</span><span> window</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">is_open</span><span>() </span><span style="color:#81a1c1;">&amp;&amp; !</span><span>window</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">is_key_down</span><span>(Key</span><span style="color:#81a1c1;">::</span><span>Escape) {
</span><span>        window</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">update_with_buffer</span><span>(</span><span style="color:#81a1c1;">&amp;</span><span>buffer</span><span style="color:#eceff4;">, </span><span>WIDTH</span><span style="color:#eceff4;">, </span><span>HEIGHT)</span><span style="color:#81a1c1;">?</span><span style="color:#eceff4;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#8fbcbb;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<p>Let's write a function to evaluate \(f_c(z) = z^2 + c\).
For the sake of clarity \(z_a = x\) and \(z_b = y\) where \(z_a\) is the real component and \(z_b\) the imaginary component of the complex number \(z\). Similarly \(c_a = x_0\) and \(c_b = y_0\). I've chosen this notation to be consistent with the wikipedia page on the mandelbrot set.</p>
<p>Rust doesn't have an inbuilt complex number primitive so we could either create our own struct or operate directly on the real and imaginary components. I've opted to operate directly on the components since we aren't doing much arithmetic. The following is \(f_c(z)\) expressed in terms of the components of \(z\) and \(c\).</p>
<p>$$
f_c(z) = z^2 + c
$$
$$
=(x + yi)(x + yi) + (x_0 + y_0i)
$$
$$
=x^2 + 2xyi - y^2 + x_0 + y_0i
$$
$$
= (x^2 - y^2 + x_0) + (2xy + y_0)i
$$</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">iterate</span><span>(x</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span>(</span><span style="color:#81a1c1;">f64</span><span>, </span><span style="color:#81a1c1;">f64</span><span>) {
</span><span>    (x </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">-</span><span> y </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> x0</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> y0)
</span><span>}
</span></code></pre>
<p>Now let's create a function to tell if for given \(c\) value our recursive sequence diverges or not. One of the basic properties of our sequence
is that it will diverge if at any point \(|f_c(z)| &gt; 2\) (or alternatively \(|f_c(z)|^2 &gt; 4\)). This is because the entire mandelbrot set lies within a circle with radius 2. Using this property we can check for a given \(c\) value if the sequence will diverge within a given amount of iterations.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">const </span><span>ITERATIONS</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span style="color:#b48ead;">1024</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">...
</span><span>
</span><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">bool </span><span>{
</span><span>    </span><span style="color:#616e88;">// the first z value is always 0
</span><span>    </span><span style="color:#81a1c1;">let </span><span>(</span><span style="color:#81a1c1;">mut</span><span> x</span><span style="color:#eceff4;">, </span><span style="color:#81a1c1;">mut</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(</span><span style="color:#b48ead;">0.0</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">0.0</span><span>)</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#616e88;">// check if our function diverges within a given amount of iterations
</span><span>    </span><span style="color:#81a1c1;">for _ in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        (x</span><span style="color:#eceff4;">,</span><span> y) </span><span style="color:#81a1c1;">= </span><span style="color:#88c0d0;">iterate</span><span>(x</span><span style="color:#eceff4;">,</span><span> y</span><span style="color:#eceff4;">,</span><span> x0</span><span style="color:#eceff4;">,</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#616e88;">// if |z|^2 &gt; 4 the sequence diverges
</span><span>        </span><span style="color:#81a1c1;">let</span><span> mag_squared </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">+</span><span> y </span><span style="color:#81a1c1;">*</span><span> y</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">if</span><span> mag_squared </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return true</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#81a1c1;">false
</span><span>}
</span></code></pre>
<p>We can now use this to graph the mandelbrot set! We'll assign the colour white to anything that fails to diverge and black to everything else.
The entire mandelbrot set lies between \(-2 - 1.2i\) and \(0.5 + 1.2i\) so let's map the pixels of our image to between those values.</p>
<p>For example to map our pixels \(y\) coordinates to our \(i\) range we can use the following formula: \(y_{min} + y_{range}\frac{p_{y}}{p_{ymax}}\), we do the same for mapping our pixels \(x\) coordinates to our real number range.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">use </span><span>minifb</span><span style="color:#81a1c1;">::</span><span>{Key</span><span style="color:#eceff4;">,</span><span> Window</span><span style="color:#eceff4;">,</span><span> WindowOptions}</span><span style="color:#eceff4;">;
</span><span style="color:#81a1c1;">use </span><span>std</span><span style="color:#81a1c1;">::</span><span>error</span><span style="color:#81a1c1;">::</span><span>Error</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">const </span><span>WIDTH</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span style="color:#b48ead;">2560</span><span style="color:#eceff4;">;
</span><span style="color:#81a1c1;">const </span><span>HEIGHT</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span style="color:#b48ead;">1440</span><span style="color:#eceff4;">;
</span><span style="color:#81a1c1;">const </span><span>ITERATIONS</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span style="color:#b48ead;">1024</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">main</span><span>() </span><span style="color:#eceff4;">-&gt; </span><span style="color:#8fbcbb;">Result</span><span>&lt;(), </span><span style="color:#8fbcbb;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    </span><span style="color:#81a1c1;">let mut</span><span> buffer</span><span style="color:#eceff4;">: </span><span style="color:#8fbcbb;">Vec</span><span>&lt;</span><span style="color:#81a1c1;">u32</span><span>&gt; </span><span style="color:#81a1c1;">= </span><span>vec![</span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">; </span><span>WIDTH </span><span style="color:#81a1c1;">* </span><span>HEIGHT]</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#616e88;">// record how long the render takes
</span><span>    </span><span style="color:#81a1c1;">let</span><span> render_start </span><span style="color:#81a1c1;">= </span><span>std</span><span style="color:#81a1c1;">::</span><span>time</span><span style="color:#81a1c1;">::</span><span>Instant</span><span style="color:#81a1c1;">::</span><span>now()</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">for </span><span>(i</span><span style="color:#eceff4;">,</span><span> pixel) </span><span style="color:#81a1c1;">in</span><span> buffer</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">iter_mut</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">enumerate</span><span>() {
</span><span>        </span><span style="color:#81a1c1;">let </span><span>(pixel_x</span><span style="color:#eceff4;">,</span><span> pixel_y) </span><span style="color:#81a1c1;">= </span><span>(i </span><span style="color:#81a1c1;">% </span><span>WIDTH</span><span style="color:#eceff4;">,</span><span> i </span><span style="color:#81a1c1;">/ </span><span>WIDTH)</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#616e88;">// map pixels to between -2 - 1.2i and 0.5 + 1.2i
</span><span>        </span><span style="color:#81a1c1;">let</span><span> x0 </span><span style="color:#81a1c1;">= -</span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">+ </span><span style="color:#b48ead;">2.5 </span><span style="color:#81a1c1;">* </span><span>(pixel_x </span><span style="color:#81a1c1;">as f64 / </span><span>(WIDTH </span><span style="color:#81a1c1;">- </span><span style="color:#b48ead;">1</span><span>) </span><span style="color:#81a1c1;">as f64</span><span>)</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">let</span><span> y0 </span><span style="color:#81a1c1;">= -</span><span style="color:#b48ead;">1.2 </span><span style="color:#81a1c1;">+ </span><span style="color:#b48ead;">2.4 </span><span style="color:#81a1c1;">* </span><span>(pixel_y </span><span style="color:#81a1c1;">as f64 / </span><span>(HEIGHT </span><span style="color:#81a1c1;">- </span><span style="color:#b48ead;">1</span><span>) </span><span style="color:#81a1c1;">as f64</span><span>)</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#616e88;">// if the function fails to diverge at c within ITERATIONS set the pixel to white
</span><span>        </span><span style="color:#81a1c1;">if !</span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">,</span><span> y0) {
</span><span>            </span><span style="color:#81a1c1;">*</span><span>pixel </span><span style="color:#81a1c1;">= u32::</span><span>MAX</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    println!(
</span><span>        </span><span style="color:#a3be8c;">&quot;Render completed in </span><span style="color:#ebcb8b;">{}</span><span style="color:#a3be8c;">ms&quot;</span><span style="color:#eceff4;">,
</span><span>        render_start</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">elapsed</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">as_millis</span><span>()
</span><span>    )</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">...
</span><span>}
</span></code></pre>
<p>This takes around 3 seconds with my 5950x and produces this image:
<img src="nonl.knao.net/mandelbrotset/01.webp" alt="first mandlebrot image" /></p>
<p>The resulting image is rather underwelming to say the least, a lot of the interesting detail isn't there!
This is due to our binary diverges/doesn't diverge approach. Before we improve on that aspect that let's speed up the render.</p>
<h3 id="multithreading">Multithreading</h3>
<p>Perhaps the easiest speedup would be to convert our single-threaded render loop to a multi-threaded,
we can do this with rayon by replacing <code>for (i, pixel) in buffer.iter_mut().enumerate() { ... }</code> with
<code>buffer.par_iter_mut().enumerate().for_each(|(i, pixel)| { ... });</code></p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">use </span><span>rayon</span><span style="color:#81a1c1;">::</span><span>prelude</span><span style="color:#81a1c1;">::*</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">...
</span><span>
</span><span>    buffer</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">par_iter_mut</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">enumerate</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">for_each</span><span>(|(i</span><span style="color:#eceff4;">, </span><span>pixel)| {
</span><span>        </span><span style="color:#81a1c1;">let </span><span>(pixel_x</span><span style="color:#eceff4;">,</span><span> pixel_y) </span><span style="color:#81a1c1;">= </span><span>(i </span><span style="color:#81a1c1;">% </span><span>WIDTH</span><span style="color:#eceff4;">,</span><span> i </span><span style="color:#81a1c1;">/ </span><span>WIDTH)</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#81a1c1;">let</span><span> x0 </span><span style="color:#81a1c1;">= -</span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">+ </span><span style="color:#b48ead;">2.5 </span><span style="color:#81a1c1;">* </span><span>(pixel_x </span><span style="color:#81a1c1;">as f64 / </span><span>(WIDTH </span><span style="color:#81a1c1;">- </span><span style="color:#b48ead;">1</span><span>) </span><span style="color:#81a1c1;">as f64</span><span>)</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">let</span><span> y0 </span><span style="color:#81a1c1;">= -</span><span style="color:#b48ead;">1.2 </span><span style="color:#81a1c1;">+ </span><span style="color:#b48ead;">2.4 </span><span style="color:#81a1c1;">* </span><span>(pixel_y </span><span style="color:#81a1c1;">as f64 / </span><span>(HEIGHT </span><span style="color:#81a1c1;">- </span><span style="color:#b48ead;">1</span><span>) </span><span style="color:#81a1c1;">as f64</span><span>)</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#81a1c1;">if !</span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">,</span><span> y0) {
</span><span>            </span><span style="color:#81a1c1;">*</span><span>pixel </span><span style="color:#81a1c1;">= u32::</span><span>MAX</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>    })</span><span style="color:#eceff4;">;
</span></code></pre>
<p>The render now takes around 130ms on my 5950x (16 cores, 32 threads) which is about a ~23x speedup!</p>
<h3 id="optimising">Optimising</h3>
<p>We can also optimise our diverges function. We'll need to inline our iterate function so let's do that.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">bool </span><span>{
</span><span>    </span><span style="color:#81a1c1;">let </span><span>(</span><span style="color:#81a1c1;">mut</span><span> x</span><span style="color:#eceff4;">, </span><span style="color:#81a1c1;">mut</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(</span><span style="color:#b48ead;">0.0</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">0.0</span><span>)</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">for _ in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        </span><span style="color:#616e88;">// iterate
</span><span>        (x</span><span style="color:#eceff4;">,</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(x </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">-</span><span> y </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> x0</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#81a1c1;">let</span><span> mag_sq </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">+</span><span> y </span><span style="color:#81a1c1;">*</span><span> y</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">if</span><span> mag_sq </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return true</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#81a1c1;">false
</span><span>}
</span></code></pre>
<p>First of all we can move the <code>mag_sqaured &gt; 4.0</code> check to the start of the loop and start with the values from the first iteration.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">bool </span><span>{
</span><span>    </span><span style="color:#81a1c1;">let </span><span>(</span><span style="color:#81a1c1;">mut</span><span> x</span><span style="color:#eceff4;">, </span><span style="color:#81a1c1;">mut</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(x0</span><span style="color:#eceff4;">,</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">for _ in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        </span><span style="color:#81a1c1;">let</span><span> mag_sq </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">+</span><span> y </span><span style="color:#81a1c1;">*</span><span> y</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">if</span><span> mag_sq </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return true</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#616e88;">// iterate
</span><span>        (x</span><span style="color:#eceff4;">,</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(x </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">-</span><span> y </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> x0</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>    }
</span><span>    </span><span style="color:#81a1c1;">false
</span><span>}
</span></code></pre>
<p>This gets us to around ~118ms. We can also store the values of \(x^2\) and \(y^2\) which removes some duplicate calculations.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">bool </span><span>{
</span><span>    </span><span style="color:#81a1c1;">let </span><span>(</span><span style="color:#81a1c1;">mut</span><span> x</span><span style="color:#eceff4;">, </span><span style="color:#81a1c1;">mut</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(x0</span><span style="color:#eceff4;">,</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">for _ in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        </span><span style="color:#81a1c1;">let</span><span> x_sq </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">*</span><span> x</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">let</span><span> y_sq </span><span style="color:#81a1c1;">=</span><span> y </span><span style="color:#81a1c1;">*</span><span> y</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#81a1c1;">if</span><span> x_sq </span><span style="color:#81a1c1;">+</span><span> y_sq </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return true</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        (x</span><span style="color:#eceff4;">,</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(x_sq </span><span style="color:#81a1c1;">-</span><span> y_sq </span><span style="color:#81a1c1;">+</span><span> x0</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>    }
</span><span>    </span><span style="color:#81a1c1;">false
</span><span>}
</span></code></pre>
<p>This doesn't seem to make a noticable difference in my case but I'm going to stick with it since it makes the code a bit neater.</p>
<h4 id="early-exit">Early Exit</h4>
<p>A big problem with our program is that if a point falls within the main cardiod or the period 2 bulb (the circle to the left) we know that it will not diverge but our program does not which means we will go through all (1024) iterations. Let's add a check to early exit if this is the case.</p>
<p>We can check if the a point is in the main cardoid with the following:
$$
q = (x-\frac{1}{4})^2 + y^2
$$
$$
4q(q + (x - \frac{1}{4})) \leq y^2
$$
We can check if a point is in the period 2 bulb with the following:
$$
(x + 1)^2 + y^2 \leq \frac{1}{16}
$$</p>
<p>Implementing this in code might look like this:</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">bool </span><span>{
</span><span>    </span><span style="color:#81a1c1;">let </span><span>(</span><span style="color:#81a1c1;">mut</span><span> x</span><span style="color:#eceff4;">, </span><span style="color:#81a1c1;">mut</span><span> y) </span><span style="color:#81a1c1;">= </span><span>(x0</span><span style="color:#eceff4;">,</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#81a1c1;">let </span><span>(</span><span style="color:#81a1c1;">mut</span><span> x_sq</span><span style="color:#eceff4;">, </span><span style="color:#81a1c1;">mut</span><span> y_sq) </span><span style="color:#81a1c1;">= </span><span>(x0 </span><span style="color:#81a1c1;">*</span><span> x0</span><span style="color:#eceff4;">,</span><span> y0 </span><span style="color:#81a1c1;">*</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#616e88;">// early exit
</span><span>    </span><span style="color:#81a1c1;">let</span><span> t </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">- </span><span style="color:#b48ead;">0.25</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#81a1c1;">let</span><span> t2 </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">+ </span><span style="color:#b48ead;">1.0</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#81a1c1;">let</span><span> q </span><span style="color:#81a1c1;">=</span><span> t </span><span style="color:#81a1c1;">*</span><span> t </span><span style="color:#81a1c1;">+</span><span> y_sq</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#616e88;">// check if point lies within the main cardoid or the period 2 bulb
</span><span>    </span><span style="color:#81a1c1;">if </span><span style="color:#b48ead;">4.0 </span><span style="color:#81a1c1;">*</span><span> q </span><span style="color:#81a1c1;">* </span><span>(q </span><span style="color:#81a1c1;">+</span><span> t) </span><span style="color:#81a1c1;">&lt;=</span><span> y_sq </span><span style="color:#81a1c1;">||</span><span> t2 </span><span style="color:#81a1c1;">*</span><span> t2 </span><span style="color:#81a1c1;">+</span><span> y_sq </span><span style="color:#81a1c1;">&lt;= </span><span style="color:#b48ead;">0.0625 </span><span>{
</span><span>        </span><span style="color:#81a1c1;">return false</span><span style="color:#eceff4;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#616e88;">// check if our function diverges within a given amount of iterations
</span><span>    </span><span style="color:#81a1c1;">for _ in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        </span><span style="color:#616e88;">// if |z|^2 &gt; 4 it diverges
</span><span>        </span><span style="color:#81a1c1;">if</span><span> x_sq </span><span style="color:#81a1c1;">+</span><span> y_sq </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return true</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#616e88;">// iterate
</span><span>        y </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> y0</span><span style="color:#eceff4;">;
</span><span>        x </span><span style="color:#81a1c1;">=</span><span> x_sq </span><span style="color:#81a1c1;">-</span><span> y_sq </span><span style="color:#81a1c1;">+</span><span> x0</span><span style="color:#eceff4;">;
</span><span>        y_sq </span><span style="color:#81a1c1;">=</span><span> y </span><span style="color:#81a1c1;">*</span><span> y</span><span style="color:#eceff4;">;
</span><span>        x_sq </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">*</span><span> x</span><span style="color:#eceff4;">;
</span><span>    }
</span><span>    </span><span style="color:#81a1c1;">false
</span><span>}
</span></code></pre>
<p>Note that I've also calculated the initial x and y squared outside of loop. I've found that doing this before applying the early exit optimisation reduces performance by around ~20ms to ~140ms for some reason. It doesn't seem to make a noticable difference after implementing the early exit.</p>
<p>After implementing early exit the render time is around 17ms.</p>
<h4 id="symmetry">Symmetry</h4>
<p>The Mandelbrot set is symmetric aross the x axis / real number line. We can take this to our advantage to only render the top half of the image then flip it.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">const </span><span>HALF_HEIGHT</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize = </span><span>HEIGHT </span><span style="color:#81a1c1;">/ </span><span style="color:#b48ead;">2</span><span style="color:#eceff4;">;
</span><span>
</span><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">main</span><span>() </span><span style="color:#eceff4;">-&gt; </span><span style="color:#8fbcbb;">Result</span><span>&lt;(), </span><span style="color:#8fbcbb;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    </span><span style="color:#81a1c1;">let mut</span><span> buffer</span><span style="color:#eceff4;">: </span><span style="color:#8fbcbb;">Vec</span><span>&lt;</span><span style="color:#81a1c1;">u32</span><span>&gt; </span><span style="color:#81a1c1;">= </span><span>vec![</span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">; </span><span>WIDTH </span><span style="color:#81a1c1;">* </span><span>HALF_HEIGHT]</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">let</span><span> render_start </span><span style="color:#81a1c1;">= </span><span>std</span><span style="color:#81a1c1;">::</span><span>time</span><span style="color:#81a1c1;">::</span><span>Instant</span><span style="color:#81a1c1;">::</span><span>now()</span><span style="color:#eceff4;">;
</span><span>
</span><span>    buffer</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">par_iter_mut</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">enumerate</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">for_each</span><span>(|(i</span><span style="color:#eceff4;">, </span><span>pixel)| {
</span><span>        </span><span style="color:#81a1c1;">...
</span><span>    })</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">let</span><span> second_half </span><span style="color:#81a1c1;">=</span><span> buffer
</span><span>        </span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">chunks</span><span>(WIDTH)
</span><span>        </span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">rev</span><span>()
</span><span>        </span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">flatten</span><span>()
</span><span>        </span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">copied</span><span>()
</span><span>        </span><span style="color:#81a1c1;">.</span><span>collect</span><span style="color:#81a1c1;">::</span><span>&lt;</span><span style="color:#8fbcbb;">Vec</span><span>&lt;</span><span style="color:#81a1c1;">u32</span><span>&gt;&gt;()</span><span style="color:#eceff4;">;
</span><span>
</span><span>    buffer</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">extend</span><span>(second_half)</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">...
</span><span>}
</span></code></pre>
<p>This brings the render time down to around 14ms. I suspect that there are unnesscary allocations but it works well enough.</p>
<h4 id="cycles">Cycles</h4>
<p>Another optimisation we can make is checking for cycles while we are iterating, if we detect a cycle it means that point will never diverge so we can exit early.</p>
<p>To detect cycles we can store the initial value of z after the first iteration and check if any of the preceding z values match. We can update our value of z ever so often since cycles don't have to start from the first z value.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">bool </span><span>{
</span><span>    </span><span style="color:#81a1c1;">...
</span><span>
</span><span>    </span><span style="color:#616e88;">// values for cycle checking
</span><span>    </span><span style="color:#81a1c1;">let mut</span><span> x_old </span><span style="color:#81a1c1;">=</span><span> x0</span><span style="color:#eceff4;">;
</span><span>    </span><span style="color:#81a1c1;">let mut</span><span> y_old </span><span style="color:#81a1c1;">=</span><span> y0</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#616e88;">// check if our function diverges within a given amount of iterations
</span><span>    </span><span style="color:#81a1c1;">for</span><span> depth </span><span style="color:#81a1c1;">in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        </span><span style="color:#616e88;">// if |z|^2 &gt; 4 it diverges
</span><span>        </span><span style="color:#81a1c1;">if</span><span> x_sq </span><span style="color:#81a1c1;">+</span><span> y_sq </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return true</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#616e88;">// iterate
</span><span>        y </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">2.0 </span><span style="color:#81a1c1;">*</span><span> x </span><span style="color:#81a1c1;">*</span><span> y </span><span style="color:#81a1c1;">+</span><span> y0</span><span style="color:#eceff4;">;
</span><span>        x </span><span style="color:#81a1c1;">=</span><span> x_sq </span><span style="color:#81a1c1;">-</span><span> y_sq </span><span style="color:#81a1c1;">+</span><span> x0</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#616e88;">// check if in cycle
</span><span>        </span><span style="color:#81a1c1;">if </span><span>(x </span><span style="color:#81a1c1;">-</span><span> x_old)</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">abs</span><span>() </span><span style="color:#81a1c1;">&lt; </span><span style="color:#b48ead;">0.000001 </span><span style="color:#81a1c1;">&amp;&amp; </span><span>(y </span><span style="color:#81a1c1;">-</span><span> y_old)</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">abs</span><span>() </span><span style="color:#81a1c1;">&lt; </span><span style="color:#b48ead;">0.000001 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return false</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        y_sq </span><span style="color:#81a1c1;">=</span><span> y </span><span style="color:#81a1c1;">*</span><span> y</span><span style="color:#eceff4;">;
</span><span>        x_sq </span><span style="color:#81a1c1;">=</span><span> x </span><span style="color:#81a1c1;">*</span><span> x</span><span style="color:#eceff4;">;
</span><span>
</span><span>        </span><span style="color:#616e88;">// update cycle point every 20 iterations
</span><span>        </span><span style="color:#81a1c1;">if</span><span> depth </span><span style="color:#81a1c1;">% </span><span style="color:#b48ead;">20 </span><span style="color:#81a1c1;">== </span><span style="color:#b48ead;">0 </span><span>{
</span><span>            x_old </span><span style="color:#81a1c1;">=</span><span> x</span><span style="color:#eceff4;">;
</span><span>            y_old </span><span style="color:#81a1c1;">=</span><span> y</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#81a1c1;">false
</span><span>}
</span></code></pre>
<p>This brings down the render time to around 12ms.</p>
<h3 id="better-graphing">Better graphing</h3>
<p>Currently we have a binary diverges/doesn't diverge colouring which leaves out a lot of detail. Instead we can colour based on how many iterations it takes it cross our 2 threshold.</p>
<p>First let's modify the diverges function to return the iteration it crossed our 2 threshold on or otherwise return the max iteration.</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>, y0</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">f64</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">usize </span><span>{
</span><span>    </span><span style="color:#81a1c1;">...
</span><span>
</span><span>    </span><span style="color:#616e88;">// early exit for period 2 bulb or cardoid
</span><span>    </span><span style="color:#81a1c1;">if </span><span style="color:#b48ead;">4.0 </span><span style="color:#81a1c1;">*</span><span> q </span><span style="color:#81a1c1;">* </span><span>(q </span><span style="color:#81a1c1;">+</span><span> t) </span><span style="color:#81a1c1;">&lt;=</span><span> y_sq </span><span style="color:#81a1c1;">||</span><span> t2 </span><span style="color:#81a1c1;">*</span><span> t2 </span><span style="color:#81a1c1;">+</span><span> y_sq </span><span style="color:#81a1c1;">&lt;= </span><span style="color:#b48ead;">0.0625 </span><span>{
</span><span>        </span><span style="color:#81a1c1;">return </span><span>ITERATIONS</span><span style="color:#eceff4;">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#81a1c1;">...
</span><span>
</span><span>    </span><span style="color:#616e88;">// check if our function diverges within a given amount of iterations
</span><span>    </span><span style="color:#81a1c1;">for</span><span> depth </span><span style="color:#81a1c1;">in </span><span style="color:#b48ead;">0</span><span style="color:#81a1c1;">..</span><span>ITERATIONS {
</span><span>        </span><span style="color:#616e88;">// if |z|^2 &gt; 4 it diverges
</span><span>        </span><span style="color:#81a1c1;">if</span><span> x_sq </span><span style="color:#81a1c1;">+</span><span> y_sq </span><span style="color:#81a1c1;">&gt; </span><span style="color:#b48ead;">4.0 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return</span><span> depth</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#81a1c1;">...
</span><span>
</span><span>        </span><span style="color:#616e88;">// check if in cycle
</span><span>        </span><span style="color:#81a1c1;">if </span><span>(x </span><span style="color:#81a1c1;">-</span><span> x_old)</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">abs</span><span>() </span><span style="color:#81a1c1;">&lt; </span><span style="color:#b48ead;">0.000001 </span><span style="color:#81a1c1;">&amp;&amp; </span><span>(y </span><span style="color:#81a1c1;">-</span><span> y_old)</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">abs</span><span>() </span><span style="color:#81a1c1;">&lt; </span><span style="color:#b48ead;">0.000001 </span><span>{
</span><span>            </span><span style="color:#81a1c1;">return </span><span>ITERATIONS</span><span style="color:#eceff4;">;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#81a1c1;">...
</span><span>    }
</span><span>    ITERATIONS
</span><span>}
</span><span>
</span></code></pre>
<p>Lets create a function that takes iteration and returns a colour:</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#81a1c1;">fn </span><span style="color:#88c0d0;">colour_from_iteration</span><span>(depth</span><span style="color:#eceff4;">: </span><span style="color:#81a1c1;">usize</span><span>) </span><span style="color:#eceff4;">-&gt; </span><span style="color:#81a1c1;">u32 </span><span>{
</span><span>    </span><span style="color:#81a1c1;">let</span><span> t </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">1.0 </span><span style="color:#81a1c1;">-</span><span> depth </span><span style="color:#81a1c1;">as f64 / </span><span>ITERATIONS </span><span style="color:#81a1c1;">as f64</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#81a1c1;">let</span><span> greyscale </span><span style="color:#81a1c1;">= </span><span>((</span><span style="color:#b48ead;">1.0 </span><span style="color:#81a1c1;">-</span><span> t</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">powi</span><span>(</span><span style="color:#b48ead;">10</span><span>)) </span><span style="color:#81a1c1;">* </span><span style="color:#b48ead;">255.0</span><span>) </span><span style="color:#81a1c1;">as u32</span><span style="color:#eceff4;">;
</span><span>
</span><span>    </span><span style="color:#616e88;">// minifb uses 0RGB so this represents rgb(greyscale, greyscale, greyscale)
</span><span>    greyscale </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#b48ead;">16 </span><span style="color:#81a1c1;">|</span><span> greyscale </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#b48ead;">8 </span><span style="color:#81a1c1;">|</span><span> greyscale
</span><span>}
</span></code></pre>
<p>The above interpolates between black and white given an iteration count.</p>
<p>We also need to modify our buffer creation:</p>
<pre data-lang="rust" style="background-color:#2e3440;color:#d8dee9;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    buffer</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">par_iter_mut</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">enumerate</span><span>()</span><span style="color:#81a1c1;">.</span><span style="color:#88c0d0;">for_each</span><span>(|(i</span><span style="color:#eceff4;">, </span><span>pixel)| {
</span><span>        </span><span style="color:#81a1c1;">...
</span><span>
</span><span>        </span><span style="color:#81a1c1;">let</span><span> depth </span><span style="color:#81a1c1;">= </span><span style="color:#88c0d0;">diverges</span><span>(x0</span><span style="color:#eceff4;">,</span><span> y0)</span><span style="color:#eceff4;">;
</span><span>        </span><span style="color:#81a1c1;">*</span><span>pixel </span><span style="color:#81a1c1;">= </span><span style="color:#88c0d0;">colour_from_iteration</span><span>(depth)</span><span style="color:#eceff4;">;
</span><span>    })</span><span style="color:#eceff4;">;
</span></code></pre>
<p>We now get this image:
<img src="nonl.knao.net/mandelbrotset/02.webp" alt="final mandelbrot image" /></p>
<h3 id="conclusion">Conclusion</h3>
<p>For me this is where I stop. If you want to explore more around this topic such as more advanced algorithms or different colourings have a look at <a href="https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set">wikipedia</a> where I got most of this information from.</p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="nonl.knao.net/tags/graphics/">#graphics</a>
                    
                </div>
            
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="nonl.knao.net/even.js" ></script>
      
    </body>

</html>
